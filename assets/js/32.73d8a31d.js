(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{159:function(a,t,s){"use strict";s.r(t);var e=s(18),r=Object(e.a)({},function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"进程管理（pm2）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程管理（pm2）","aria-hidden":"true"}},[a._v("#")]),a._v(" 进程管理（PM2）")]),a._v(" "),s("p",[a._v("Akos框架采用PM2进行进程管理，PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有 CPU，并保证进程\n永远都活着，0 秒的重载， PM2 是完美的。它非常适合 IaaS 结构，但不要把它用于 PaaS 方案（随后将开发 Paas 的解决方案）。")]),a._v(" "),s("h2",{attrs:{id:"主要特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要特性","aria-hidden":"true"}},[a._v("#")]),a._v(" 主要特性")]),a._v(" "),s("ul",[s("li",[a._v("内建负载均衡（使用 Node cluster 集群模块）")]),a._v(" "),s("li",[a._v("后台运行")]),a._v(" "),s("li",[a._v("0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.")]),a._v(" "),s("li",[a._v("具有 Ubuntu 和 CentOS 的启动脚本")]),a._v(" "),s("li",[a._v("停止不稳定的进程（避免无限循环）")]),a._v(" "),s("li",[a._v("控制台检测")]),a._v(" "),s("li",[a._v("提供 HTTP API")]),a._v(" "),s("li",[a._v("远程控制和实时的接口 API ( Nodejs 模块，允许和 PM2 进程管理器交互 )")])]),a._v(" "),s("h2",{attrs:{id:"安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安装","aria-hidden":"true"}},[a._v("#")]),a._v(" 安装")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("npm install -g pm2\n")])])]),s("h2",{attrs:{id:"采用命令行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#采用命令行","aria-hidden":"true"}},[a._v("#")]),a._v(" 采用命令行")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("$ npm install pm2 -g     # 命令行安装 pm2\n$ pm2 start app.js -i 4  # 后台运行pm2，启动4个app.js\n                         # 也可以把'max' 参数传递给 start\n                         # 正确的进程数目依赖于Cpu的核心数目\n$ pm2 start app.js --name my-api # 命名进程\n$ pm2 list               # 显示所有进程状态\n$ pm2 monit              # 监视所有进程\n$ pm2 logs               # 显示所有进程日志\n$ pm2 stop all           # 停止所有进程\n$ pm2 restart all        # 重启所有进程\n$ pm2 reload all         # 0 秒停机重载进程 (用于 NETWORKED 进程)\n$ pm2 stop 0             # 停止指定的进程\n$ pm2 restart 0          # 重启指定的进程\n$ pm2 startup            # 产生 init 脚本 保持进程活着\n$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)\n$ pm2 delete 0           # 杀死指定的进程\n")])])]),s("h2",{attrs:{id:"启动服务的不同方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启动服务的不同方式","aria-hidden":"true"}},[a._v("#")]),a._v(" 启动服务的不同方式")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("$ pm2 start app.js -i max    # 根据有效CPU数目启动最大进程数目\n$ pm2 start app.js -i 3      # 启动3个进程\n$ pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster\n$ pm2 start app.js -x -- -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)\n$ pm2 start app.js --name serverone  # 启动一个进程并把它命名为 serverone\n$ pm2 stop serverone       # 停止 serverone 进程\n$ pm2 start app.json        # 启动进程, 在 app.json里设置选项\n$ pm2 start app.js -i max -- -a 23                   #在--之后给 app.js 传递参数\n$ pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件\n你也可以执行用其他语言编写的app  ( fork 模式):\n$ pm2 start my-bash-script.sh    -x --interpreter bash\n$ pm2 start my-python-script.py -x --interpreter python\n")])])]),s("p",[a._v("0 秒停机重载：这项功能允许你重新载入代码而不用失去请求连接。")])])},[],!1,null,null,null);r.options.__file="pm2.md";t.default=r.exports}}]);
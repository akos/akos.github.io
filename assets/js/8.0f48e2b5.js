(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{160:function(e,n,t){"use strict";t.r(n);var a=t(18),o=Object(a.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"node-js的基本运行原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js的基本运行原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Node.js的基本运行原理")]),e._v(" "),t("h3",{attrs:{id:"node-js文件目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js文件目录","aria-hidden":"true"}},[e._v("#")]),e._v(" Node.js文件目录")]),e._v(" "),t("pre",[t("code",[e._v(".\n├── ...\n├── deps\n│   ├── ...\n│   ├── v8\n│   ├── ...\n├── ...\n├── lib\n│   ├── ...\n│   ├── buffer.js\n│   ├── child_process.js\n│   ├── console.js\n│   ├── ...\n├── node -> out/Release/node\n├── ...\n├── out\n│   ├── ...\n│   ├── Release\n|         ├── node\n|         ├── node.d\n|         ├── obj\n|             └── gen\n|                 ├── ...\n|                 ├── node_natives.h\n|                 ├── ...\n│   ├── ...\n├── src\n│   ├── ...\n│   ├── debug-agent.cc\n│   ├── debug-agent.h\n│   ├── env-inl.h\n│   ├── env.cc\n│   ├── ...\n├──\n...\n")])]),e._v(" "),t("p",[e._v("需要关注的几个目录和文件：")]),e._v(" "),t("p",[e._v("/deps/v8：这里是V8源码所在文件夹，你会发现里面的目录结构跟V8源码十分相似。NodeJS除了移植V8源码，还在增添了一些内容。")]),e._v(" "),t("p",[e._v("/src：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」")]),e._v(" "),t("p",[e._v("/lib：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的js2c.py工具，把所有内置的JavaScript代码转换成C++里面的数组，生成out/Release/obj/gen/node_natives.h文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。")]),e._v(" "),t("p",[e._v("/out：该目录是Node源码编译(即命令行运行make)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入node xxx.js，实际就是运行了out/Release/node文件。\n![](/assets/popo_2018-08-28  19-59-37.jpg)")]),e._v(" "),t("p",[e._v("Node在"),t("strong",[e._v("启动")]),e._v("的时候，就已经"),t("strong",[e._v("把 Native Module，Builtin Module 加载到内存里面了")]),e._v("，这样可以供全局使用。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。")]),e._v(" "),t("p",[e._v("V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。")]),e._v(" "),t("p",[e._v("JavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。\n与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，初期时并没有二进制码或其他的中间码，到"),t("strong",[e._v("2017年上旬引入中间字节码的概念")]),e._v("。")]),e._v(" "),t("p",[e._v("简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」\n但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：")]),e._v(" "),t("pre",[t("code",[e._v("    1.编译优化\n    2.内存管理\n    3.垃圾回收\n")])]),e._v(" "),t("h3",{attrs:{id:"c-c-编写的核心模块，调用方法基本运行原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-c-编写的核心模块，调用方法基本运行原理","aria-hidden":"true"}},[e._v("#")]),e._v(" C/C++编写的核心模块，调用方法基本运行原理")]),e._v(" "),t("pre",[t("code",[e._v('#include "v8.h"\n#include <string.h>\n#include <stdio.h>\n\nusing namespace v8;\nusing namespace std;\n\nHandle<Value> Hi(const Arguments& args) {\n    HandleScope  handle_scope;\n    char buffer[4096];\n\n    memset(buffer, 0, sizeof(buffer));\n    Handle<String> str = args[0]->ToString();\n    str->WriteAscii(buffer);\n    printf("Yell: %s\\n", buffer);\n\n    return Undefined();\n}\n\nint main(int argc, char** argv) {\n    HandleScope handle_scope;\n\n    //定义一个FunctionTempte并与C++函数绑定\n    Handle<FunctionTemplate> fun = FunctionTemplate::New(Hi);\n    //定义一个ObectTemplate，并向该对象注册一个FunctionTemplate\n    Handle<ObjectTemplate> global = ObjectTemplate::New();\n    global->Set(String::New("Hi"), fun);\n    //将该对象注册到JS的global中去\n    Persistent<Context> cxt = Context::New(NULL, global);\n\n    Context::Scope context_scope(cxt);\n    Handle<String> source = String::New("Hi(\'Hi V8!\')");\n    Handle<Script> script = Script::Compile(source);\n    Handle<Value> result = script->Run();\n\n    cxt.Dispose();\n}\n')])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("using namespace v8;\n\nint main(int argc, char* argv[]) {\n  // Get the default Isolate created at startup.\n  Isolate* isolate = Isolate::GetCurrent();\n\n  // Create a stack-allocated handle scope.\n  HandleScope handle_scope(isolate);\n\n  // Create a new context.\n  Handle<Context> context = Context::New(isolate);\n\n  // Here's how you could create a Persistent handle to the context, if needed.\n  Persistent<Context> persistent_context(isolate, context);\n\n  // Enter the created context for compiling and\n  // running the hello world script.\n  Context::Scope context_scope(context);\n\n  // 创建一个js的字符串的文件\n  Handle<String> source = String::New(\"'Hello' + ', World!'\");\n\n  // 编译原文件\n  Handle<Script> script = Script::Compile(source);\n\n  // 运行Js得到返回结果.\n  Handle<Value> result = script->Run();\n\n  // The persistent handle needs to be eventually disposed.\n  persistent_context.Dispose();\n\n  // Convert the result to an ASCII string and print it.\n  String::AsciiValue ascii(result);\n  printf(\"%s\\n\", *ascii);\n  return 0;\n")])])])])},[],!1,null,null,null);o.options.__file="basic-principle-of-nodejs.md";n.default=o.exports}}]);